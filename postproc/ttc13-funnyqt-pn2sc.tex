\documentclass[submission]{eptcs}
\providecommand{\event}{Transformation Tool Contest 2013 (TTC'13)}
\def\titlerunning{Solving the Petri-Nets to Statecharts Transformation Case with FunnyQT}
\def\authorrunning{Tassilo Horn}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{paralist}
\usepackage{verbatim}
\usepackage{footmisc}

\makeatletter
\def\verbatim@font{\ttfamily\small}
\makeatother

\usepackage{minted}
\newminted{clojure}{fontsize=\footnotesize,frame=lines,linenos}

\title{Solving the Petri-Nets to Statecharts Transformation Case with FunnyQT}
\author{Dipl.-Inform. Tassilo Horn
  \email{horn@uni-koblenz.de}
  \institute{Institute for Software Technology, University Koblenz-Landau, Germany}}

\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

%% Reduce the space between image and captions
\setlength\abovecaptionskip{0.1cm}
\setlength\belowcaptionskip{0cm}


\begin{document}

\maketitle

\begin{abstract}
  FunnyQT is a model querying and model transformation library for the
  functional Lisp-dialect Clojure providing a rich and efficient querying and
  transformation API.

  This paper describes the FunnyQT solution to the TTC 2013 Petri-Nets to
  Statcharts Transformation Case.  This solution has won the \emph{best overall
    solution award} and the \emph{best efficiency award} for this case.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

\emph{FunnyQT} is a new model querying and transformation approach which is
implemented as an API for the functional, JVM-based Lisp-dialect Clojure.  It
provides several sub-APIs for implementing different kinds of queries and
transformations.  For example, there is a model-to-model transformation API,
and there is an in-place transformation API for writing programmed graph
transformations.  FunnyQT currently supports EMF and JGraLab models, and it can
be extended to other modeling frameworks, too.

For solving the tasks of this transformation case\footnote{This FunnyQT
  solution is available at \url{https://github.com/tsdh/ttc-2013-pn2sc} and on
  SHARE (image
  \textsf{TTC13::Ubuntu12LTS\_TTC13::FunnyQT.vdi})\label{fn:github}}, FunnyQT's
model transformation API has been used for the initialization transformation,
while the reduction transformation has been tackled algorithmically using the
plain querying and model manipulation APIs.

\section{The Initialization Transformation}
\label{sec:init-transformation}

The complete initialization transformation using FunnyQT's model transformation
API is shown in Listing~\ref{lst:init}.

A transformation is declared with the \verb|deftransformation| macro.  It
receives the name of the transformation, i.e., \verb|initialize-statechart|, a
vector of input and output models, and arbitrary many rules.  Here, the
argument vector declares that the transformation receives one single input
model \verb|pn| which is an EMF model, and it receives exactly one output model
\verb|sc| which is also an EMF model.  It could also receive many input or
output models, and the models could belong to different modeling frameworks as
well.

The transformation consists of two rules: \verb|place2basic-and-or|, and
\verb|transition2hyperedge|.  \verb|place2basic-and-or| receives an input
\verb|Place| and creates an \verb|OR| and a \verb|Basic| in the output model.
It also sets the new basic's name to the name of the place and assigns it as
content of the new \verb|OR|.  Finally, it sets the basic's \verb|rnext| and
\verb|next| references to the value of applying \verb|transition2hyperedge| to
any pre-transition or post-transition of the input place.
\verb|place2basic-and-or| is also a top-level rule meaning it's applied
automatically to matching elements while the non-top-level rule
\verb|transition2hyperedge| has to be called explicitly from other rules.

\begin{listing}[H]
  \begin{clojurecode}
(deftransformation initialize-statechart [[pn :emf] [sc :emf]]
  (^:top place2basic-and-or [p]
         :from 'Place
         :to [o 'OR, b 'Basic]
         (eset! b :name (eget p :name))
         (eset! b :rcontains o)
         (eset! b :rnext (map transition2hyperedge
                              (eget p :pret)))
         (eset! b :next  (map transition2hyperedge
                              (eget p :postt))))
  (transition2hyperedge [t]
         :from 'Transition
         :to [he 'HyperEdge]
         (eset! he :name (eget t :name))))
  \end{clojurecode}
  \label{lst:init}
  \caption{The initialization transformation}
\end{listing}

When a rule gets called and is applicable with respect to its declared
\verb|:from| type and \verb|:when| constraint, it creates the elements declared
in \verb|:to| in the target model, and evaluates its body.  In case there is
just one new element declared in \verb|:to|, it returns just that.  If there
are many new elements, it returns them as a vector in their declaration order.
Furthermore, a traceability mapping is created from the source element to the
rule's return value.  If a rule gets called multiple times for a single
element, the second and all following calls just return the result of the first
invocation.


\section{The Reduction Transformation}
\label{sec:reduction-transformation}

The reduction transformation is implemented algorithmically based on FunnyQT's
querying and model manipulation APIs.  It consists of four rules (functions):
\begin{compactenum}
\item The AND-rule as discussed in the case description \cite{pn2sccasedesc},
\item the OR-rule as discussed in the case description,
\item an additional, extension rule assigning hyperedges to the nearest
  \verb|Compound| state containing all their predecessor and successor
  \verb|Basic| states,
\item and a rule creating a \verb|Statechart| with an \verb|AND| top-state if
  the reduction could be completed successfully.
\end{compactenum}


\paragraph{Reduction Helper Functions.}
\label{sec:reduct-help-functions}

Before discussing the rules, some helper functions need to be introduced.
Those are \verb|pret| and \verb|postt| returning the set of
pre-/post-transitions for a given place.  Likewise, \verb|prep| and
\verb|postp| return the sets of pre-/post-places for a given transition.

\paragraph{The AND Rule.}
\label{sec:and-rule}

The AND rule is depicted in Listing~\ref{lst:and-rule}.  In contrast to the
Figure~2 in the case description \cite{pn2sccasedesc}, it doesn't delete all
places $q_1$ to $q_n$ to create a new place $p$, but instead it reuses $q_1$ as
$p$ and deletes only $q_2$ to $q_n$.  This is consistent with Louis Rose's EOL
solution, and it even feels more natural at least for algorithmic solutions.

The rule function receives the Petri-net model \verb|pn|, the statechart model
\verb|sc|, either the function \verb|prep| or \verb|postp| as
\verb|prep-or-postp|, and the traceability map atom \verb|place2or|.

\begin{listing}[H]
  \begin{clojurecode*}{firstnumber=42}
(defn and-rule [pn sc prep-or-postp place2or]
  (loop [ts (eallobjects pn 'Transition), applied false]
    (if (seq ts)
      (let [t (first ts), preps-or-postps (prep-or-postp t)]
        (if (> (count preps-or-postps) 1)
          (let [p (first preps-or-postps), prets (pret p), postts (postt p)]
            (if (forall? #(and (= prets  (pret %))
                               (= postts (postt %)))
                         (rest preps-or-postps))
              (let [new-or  (ecreate! sc 'OR), new-and (ecreate! sc 'AND)]
                (eset! new-and :contains (mapv @place2or preps-or-postps))
                (eadd! new-or  :contains new-and)
                (swap! place2or assoc p new-or)
                (doseq [op (rest preps-or-postps)]
                  (edelete! op))
                (recur (rest ts) true))
              (recur (rest ts) applied)))
          (recur (rest ts) applied)))
      applied)))
  \end{clojurecode*}
  \label{lst:and-rule}
  \caption{The AND rule}
\end{listing}

It uses \verb|loop| and \verb|recur| which implement a local tail-recursion,
i.e., a recursion that doesn't consume space on the call-stack.  \verb|loop|
defines the initial bindings, and \verb|recur| restarts the loop with new
bindings.  So initially, \verb|ts| is bound to the sequence of all transitions
in the model, and \verb|applied|, which is used to indicate to the caller if at
least one match has been found, is \verb|false|.

If there are no transitions left\footnote{\textsf{(seq coll) is the canonical
    non-emptiness check in Clojure.}} (the else-branch of the \verb|if| in line
44), the function returns with the current value of \verb|applied|.  If there
are still transitions, the first one is bound to \verb|t| and its set of pre-
or post-places is bound to \verb|preps-or-posts| (line 45).

If there aren't more than one pre- or post-places of \verb|t| (the else branch
of the \verb|if| in line 46), the \verb|loop| gets restarted with the rest of
transitions and the current value of \verb|applied|.  If there are more than
one pre- or post-places, the first one is bound to \verb|p|, and \verb|prets|
and \verb|postts| are its pre- and post-transitions (line 47).

If the other pre- or post-places don't have the same sets of pre- and
post-transitions (the else-branch of the \verb|if| in line 48), the \verb|loop|
is restarted with the remaining transitions and the current value of
\verb|applied|.  However, if the pre- and post-transitition sets are all equal,
the rule matches.  In that case, lines 51 to 56 create a new \verb|OR| and a
new \verb|AND| where the \verb|OR| contains the \verb|AND|, and the \verb|AND|
contains all the \verb|OR| states corresponding to the pre- or post-places of
the current transition \verb|t|\footnote{\textsf{@some-atom atomically
    dereferences an atom resulting in its current value.}}.  The first place
\verb|p| is preserved and its traceability mapping is updated to point to the
new \verb|OR| (line 54).  The other places are deleted in lines 55 and 56.
Finally, the \verb|loop| is restarted with the remaining transitions and an
\verb|applied| value of \verb|true|.

\paragraph{The OR Rule.}
\label{sec:or-rule}

The OR rule is depicted in Listing~\ref{lst:or-rule}.  In contrast to the case
description, it doesn't delete the places (or corresponding OR states) $q$ and
$r$ to create a new place (or corresponding OR state) $p$, but instead it
reuses $q$ as $p$ and only deletes $r$.

The \verb|or-rule| gets the Petri-net model \verb|pn|, the statechart model
\verb|sc|, and the traceability map atom \verb|place2or|.  It's mechanics for
searching for matches in terms of \verb|loop| and \verb|recur| are almost
identical to the \verb|and-rule|, so the rule is described a bit more concisely
here.  One minor difference is that the variable \verb|ts| is initially bound
to a vector of all transitions.  \verb|eallobjects| returns a lazy sequence,
that is, a sequence where elements are computed (\emph{realized}) when they are
consumed.  Since this rule deletes transitions, the fail-fast EMF model
iterator underlying the lazy sequence will break.  The explicit conversion to a
vector enforces that all transitions are computed beforehand.

\begin{listing}[H]
  \begin{clojurecode*}{firstnumber=61}
(defn or-rule [pn sc place2or]
  (loop [ts (vec (eallobjects pn 'Transition)), applied false]
    (if (seq ts)
      (let [t (first ts), preps (prep t), postps (postp t)]
        (if (= 1 (count preps) (count postps))
          (let [q (first preps), r (first postps)]
            (if (or (identical? q r)
                    (and (not (member? r (adjs q :pret :postp)))
                         (not (member? r (adjs q :postt :prep)))))
              (let [merger (@place2or q), mergee (@place2or r)]
                (when-not (identical? q r)
                  (eaddall! q :pret  (eget-raw r :pret))
                  (eaddall! q :postt (eget-raw r :postt))
                  (edelete! r)
                  (eaddall! merger :contains (eget-raw mergee :contains))
                  (edelete! mergee))
                (edelete! t)
                (recur (rest ts) true))
              (recur (rest ts) applied)))
          (recur (rest ts) applied)))
      applied)))
  \end{clojurecode*}
  \label{lst:or-rule}
  \caption{The OR rule}
\end{listing}

Lines 65 to 69 specify the application condition of the rule.  If the pre- and
post-place sets of the current transition \verb|t| both contain only a single
place \verb|q| and \verb|r|, respectively, and if either \verb|q| and \verb|r|
are identical or \verb|r| is neither reachable from \verb|q| by traversing the
\verb|pret| reference followed by the \verb|postp| reference, nor reachable
from \verb|q| by traversing the \verb|postt| followed by the \verb|prep|
reference, then \verb|t| is a matching transition.

In that case, and if \verb|q| and \verb|r| are not identical, \verb|r|'s
\verb|pret| and \verb|postt| references are merged into \verb|q|, and \verb|r|
is deleted.  Similarly, the OR states corresponding to \verb|q| (\verb|merger|)
and \verb|r| (\verb|mergee|) are merged, i.e., the contents of \verb|mergee|
are transferred to \verb|merger|, and \verb|mergee| is deleted.  Finally, the
loop is restarted with the remaining transitions and an \verb|applied| value of
\verb|true|.

In any case, the transition \verb|t| is deleted, and the rule recurs to check
the remaining transitions.

\paragraph{The Statechart Creation Rule.}
\label{sec:statechart-rule}

The final rule of the transformation is the \verb|create-top| rule shown in
Listing~\ref{lst:statechart-rule}.  It receives the target statechart model
\verb|sc| as argument.

\begin{listing}[H]
  \begin{clojurecode*}{firstnumber=88}
(defn create-top [sc]
  (let [top-ors (filter #(not (eget % :rcontains)) (eallobjects sc 'OR))]
    (when (= 1 (count top-ors))
      (let [statechart (ecreate! sc 'Statechart), top (ecreate! sc 'AND)]
        (eset! statechart :topState top)
        (eset! top :rcontains top-ors)))))
  \end{clojurecode*}
  \label{lst:statechart-rule}
  \caption{The statechart creation rule}
\end{listing}

If there is exactly one \verb|OR| state that's not contained in some other
\verb|Compound| state, the reduction process has been applied successfully.  In
that case, a new \verb|Statechart| element \verb|statechart| and a new
\verb|AND| state \verb|top| are created.  \verb|top| is set as \verb|topState|
of the \verb|statechart|, and the contents of \verb|top| are set to the single
top-level \verb|OR| state.


\paragraph{Extensions.}
\label{sec:extensions}

Two extensions were implemented for this task.  First, there is an additional
rule \verb|assign-hyperedges| that assigns each hyperedge to the nearest
compound state which contains all basic states connected by the hyperedge.
Secondly, a validation
tool\footnote{\url{https://github.com/tsdh/ttc-2013-pn2sc-validation}} has been
provided that uses FunnyQT to check result statechart models against their
expected outcome.

\section{Evaluation}
\label{sec:evaluation}

In this section, the solution is evaluated according to the evaluation criteria
listed in the case description \cite{pn2sccasedesc}.

\paragraph{Transformation correctness.}

The validation project that has been implemented as an extension to this case
allows for testing the result statechart models.  For the main test cases,
every important aspect of the result models including the containment hierarchy
and the predecessors and successors of hyperedges are checked, and for the
performance test cases, only the number of instances of every metamodel class
is checked.  All tests pass for the result models of this solution.  Similarly,
all tests pass for the result models created by the reference GrGen.NET
solution.

The validation project has also been tested with intentionally slightly wrong
models, e.g., some \verb|next| link is missing at some hyperedge, there's some
additional element, or an element is contained by the wrong \verb|Compound|
state.  In all those cases, an assertion of the validation project failed.  So
there's a high confidence that if the result models pass the tests, the
transformation producing them is correct.

\paragraph{Transformation performance.}


Table~\ref{tab:eval-times} shows the evaluation times of the initialization
tranformation, the reduction transformation, and the complete transformation
involving initialization and reduction.  The times needed for loading and
saving the models from/to XMI files, the times needed for validation, and the
times needed for creating visualizations are excluded.

The measurements have been done directly on the SHARE demo.  The evaluation
times printed there are contained in the tables third and first column,
respectively.  The second column is the difference between the value in the
third column and the value in the first column.


\begin{table}[H]
  \centering
  \begin{tabular}{| c | r | r |r |}
    \hline
    \textbf{Test Case} & \textbf{Init. only} & \textbf{Red. only} & \textbf{Init. \& Red.}\\
    \hline
    1        & 1 ms    & 81 ms & 82 ms\\
    2        & 1 ms    & 37 ms & 38 ms\\
    3        & <1 ms   & 23 ms & 24 ms\\
    4        & <1 ms   & 9 ms & 10 ms\\
    5        & <1 ms   & 2 ms  & 3 ms\\
    6        & <1 ms   & 2 ms  & 3 ms\\
    7        & <1 ms   & 15 ms & 16 ms\\
    8        & <1 ms   & 20 ms & 21 ms\\
    9        & <1 ms   & 7 ms  & 8 ms\\
    10       & <1 ms   & 7 ms  & 8 ms\\
    11       & <1 ms   & 9 ms  & 10 ms\\
    \hline
    sp200    & 12 ms   & 140 ms    & 152 ms\\
    sp300    & 18 ms   & 92 ms     & 110 ms\\
    sp400    & 24 ms   & 97 ms     & 121 ms\\
    sp500    & 28 ms   & 107 ms    & 125 ms\\
    sp1000   & 69 ms   & 223 ms    & 292 ms\\
    sp2000   & 109 ms  & 267 ms    & 376 ms\\
    sp3000   & 153 ms  & 448 ms    & 601 ms\\
    sp4000   & 226 ms  & 517 ms    & 743 ms\\
    sp5000   & 274 ms  & 743 ms    & 1017 ms\\
    sp10000  & 553 ms  & 1509 ms   & 2062 ms\\
    sp20000  & 960 ms  & 3652 ms   & 4612 ms\\
    sp40000  & 1887 ms & 9457 ms   & 11344 ms\\
    sp80000  & 3849 ms & 26442 ms  & 30291 ms\\
    sp100000 & 4755 ms & 35639 ms  & 40394 ms\\
    sp200000 & 9407 ms & 105257 ms & 114664 ms\\
    \hline
  \end{tabular}
  \caption{Evaluation times on SHARE}
  \label{tab:eval-times}
\end{table}

That the first test cases evaluate a bit slower than subsequent ones is
probably caused by the JVM just-in-time compiling critical code paths.
Fluctuations in the evaluation times of models of comparable size are also
partly caused by JVM-internals such as garbage collection.  Nevertheless, the
order of magnitude is stable across multiple runs of the transformations.

Anyhow, the evaluation times are quite good, both absolute as well as relative
compared to the input model sizes.  The initialization transformation scales
linearly with the size of the input Petri-net models.  The reduction
transformation also scales in that order of magnitude.  When taking the time
needed for the \verb|sp1000| model as a baseline, then the \verb|sp10000| model
is transformed in $0.7n$ milliseconds for $n$ being the time expected when
assuming a linear correlation between model size and execution time.  The
\verb|sp40000| model takes $n$ milliseconds, the \verb|sp100000| takes $1.6n$
milliseconds, and the \verb|sp200000| model takes $2.4n$ milliseconds.

\paragraph{Transformation understandability.}

Although the solution requires some understanding of Clojure, it shouldn't be
hard to get a grasp on it.

The initialization transformation uses a FunnyQT facility allowing to specify
typical model transformations with a syntax and semantics similar to ATL or
ETL, so people knowing these languages should feel right at home.

The reduction transformation is a bit more complex, but the application
conditions of the rules and the actions that are performed are taken quite
literally from the case description with the exception that some elements are
preserved and merged instead of replaced.

One important aspect with respect to understandability is also the fact that
the transformations are very concise.  In total, the initialization and the
reduction transformation need just the 93 lines of code that was depicted
completely in the previous sections.  The initialization transformation
including its wrapper function mangling the traceability mappings is just 23
lines of code.  The complete reduction transformation with its four rules, the
few helper functions, and the function iteratively applying the rules as long
as possible amounts to 70 lines of code.


\paragraph{Bonus criteria.}

The bonus tasks dealing with \emph{verification} and \emph{simulation support}
haven't been tackled.

The initialization transformation could be extended quite easily to deal with
the \emph{change propagation} scenarios, simply because FunnyQT transformations
are written in the full-fledged programming language Clojure having access to
any JVM library's features.  Thus, adapters performing the required changes on
the target statechart could be registered to handle notifications about new,
deleted, or updated elements in the source Petri-net using the standart EMF
notification framework.  Since the initialization transformation created a
complete traceability mapping, referring to previously created elements is
easy.

There is no support special support for \emph{reversing the transformation}, or
for defining the transformation bidirectionally in the first place.

Proper \emph{debugging support} is also not yet ready for prime-time in the
Clojure world.  There are some attempts at debuggers allowing to set
breakpoints and examine the lexical extent around the breakpoint, but those are
not too usable right now.  Another difficulty with functional languages
involving some kind of laziness is that errors might be signaled at a location
very different to where the bug is actually manifested in the source code.
Nevertheless, FunnyQT has rather good model visualization tools that have been
used while programming the reduction rules in order to visualize the matching
elements when a rule has been applicable.



\bibliographystyle{alpha}
\bibliography{ttc13-funnyqt-pn2sc}


\end{document}




%%% Local Variables:
%%% mode: latex
%%% TeX-engine: pdflatex-shell-escape
%%% TeX-master: t
%%% End:
